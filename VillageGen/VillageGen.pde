import java.util.Random;
import java.util.PriorityQueue;
import java.util.function.Function;
import java.util.function.BiFunction;
import java.util.LinkedList;
import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;
import static java.lang.Math.floorMod;
import java.util.Collections;
import java.util.List;

// Records the settings of the generator
Settings settings;

// Used to record frame time for animation, etc.
float lastMillis = 0;

// Stores the heightmap grid, and properties like gradients
Heightmap heightmap;

// Stores the lines generated by marching squares to draw the coastline TODO turn into mesh
LinkedList<PolyLine> contourLines;

LinkedList<PolyLine> coastLine;
// Stores the roads
ArrayList<StreamLine> roads;
// Stores the positons
ArrayList<Building> buildings;

RoadGenerator roadGenerator;
BuildingGenerator buildingGenerator;
MarkovGenerator markovNameGen;

HashMap<String, UIElement> ui = new HashMap<String, UIElement>();
// Used to track mouse click, turns mousePressed variable into mouseClicked
boolean mousePressed1 = false, mouseClicked = false;
boolean fastMode = false;
boolean manualMode = true;

UIText nameText;
UIText popText;
void setup() {
    size(1280, 720);
    
    // Create UI
    ui.put("buttonCollection", new UICollection(10, 10, 
        new UIButton("Generate new Map", new Runnable() {
            public void run() {
                fastMode = false;
                generateInit();
        }}, 10, 10, 16), 
        new UIButton("Fast Generate", new Runnable() {
            public void run() {
                fastMode = true;
                generateInit();
        }}, 10, 10, 16), 
        new UIButton("Save Map", new Runnable() {
            public void run() {
                saveMap();
        }}, 10, 10, 16)));
    
    nameText = new UIText("", 10, height-50);
    nameText.fontSize = 30;
    nameText.backgroundColour = color(255, 255, 255, 0);
    
    popText = new UIText("", 10, height-50);
    popText.fontSize = 16;
    popText.backgroundColour = color(255, 255, 255, 0);
    ui.put("nameText", new UICollection(10, height-50, nameText, popText));
    generateInit();
}

int phase;
IGeneratorStep[] generatorSteps;

// Initializes generation
void generateInit() {
    frameRate(100000);
    
    // Stores the settings for the generator, these can be changed in Settings, by a child class, like the example CitySettings
    settings = new Settings(width, height);
     //settings = new TownSettings(width, height);
     //settings = new CitySettings(width, height);
    
    // Initialize data structures
    contourLines = new LinkedList<PolyLine>();
    coastLine = new LinkedList<PolyLine>();
    roads = new ArrayList<StreamLine>();
    buildings = new ArrayList<Building>(); 
    
    // Create and fill heightmap
    heightmap = new Heightmap(settings.w, settings.h);
    
    heightmap.fillHeightmap();
    
    contourAndCoast();
    // Initialize the generators
    roadGenerator = new RoadGenerator(new Random(settings.mainRandom.nextLong()));
    buildingGenerator = new BuildingGenerator(new Random(settings.mainRandom.nextLong()));
    markovNameGen = new MarkovGenerator(3, "welsh.txt", settings.mainRandom.nextLong());
    generatorSteps = new IGeneratorStep[] {roadGenerator, buildingGenerator, new NameGenerator()};
    
    println(settings.w, settings.h);
    phase = 0;
    generatorSteps[phase].initGen();
    pg = null;
    
    // If not animating, iterate until done
    if (fastMode) {
        float timeStarted = millis();
        while (phase < generatorSteps.length)
            genStep();
        float timeEnded = millis();
        println("Generation time: " + (timeEnded - timeStarted)/1000f + "s");
    }
}

// Carries out one step in generation process
void genStep() {
    if (phase >= generatorSteps.length) return;
    IGeneratorStep genStep = generatorSteps[phase];    // Get current step
    genStep.run();                                     // Execute it
    if (genStep.ended()) {                             // If ended:
        genStep.endGen();                            // Call current step's end generation function, and call next step's initialize generation function
        if (++phase < generatorSteps.length) {
            generatorSteps[phase].initGen();
        }
    }
}

// Stores the drawn image of the map after generation
PGraphics pg;

// Counts time until a animation step is due
float animCounter = 0;
void draw() {
    background(0);
    // Calculate frame time
    float t = millis();
    float ms = (t = millis()) - lastMillis;
    lastMillis = t;
    
    // Converts mousePressed variable into mouseClicked
    mouseClicked = mousePressed && !mousePressed1;   // If mousePressed and not mousePressed1 (only 1 frame, as mousePressed1 is updated immediately after)
    mousePressed1 = mousePressed;                    // Updates mousePressed1 to mousePressed (1 frame behind)
    
    // Calls interact methods for UI
    for (UIElement uie : ui.values()) {
        if (uie.draw) uie.controls(ms);
    }
    
    // Select graphics object, if generation is being animated, draw to main graphics, otherwise draw to separate PGraphics object and render that each frame
    PGraphics g = pg == null ? this.g : pg;
    
    if (pg == null) {    // If still drawing to main graphics
        if (phase >= generatorSteps.length) {    // If generation is finished
            pg = createGraphics(width, height);    // Create new graphics and draw this frame to it. This will be drawn for all subsequent frames of this map
            g = pg;
            pg.beginDraw();
        }
        
        animCounter -= ms;
        // If animating and generation is not finished, do a step of generating
        if (!fastMode && !manualMode && animCounter <= 0 && phase < generatorSteps.length) {
            genStep();
            animCounter += settings.animStepTime;
        }
        
        // Draw heightmap
        g.stroke(255);
        g.noFill();
        g.strokeWeight(2f);
        g.strokeCap(ROUND);
        
        heightmap.draw(ms, g);
        
        // Draw contours
        g.strokeWeight(1.5);
        g.stroke(240);
        for (PolyLine l : contourLines) {
            l.draw(ms, g);
        }
        
        // Draw coast
        g.strokeWeight(2f);
        g.stroke(255);
        for (PolyLine l : coastLine) {
            l.draw(ms, g);
        }
        
        g.stroke(#333333);
        // Draw roads
        for (StreamLine r : roads) {
            r.draw(ms, g);
        }
        
        // Draw buildings
        for (Building b : buildings) {
            b.draw(ms, g);
        }
        
        // If drawing to pg, end here
        if (pg != null) {
            pg.endDraw();
        }
    } else {    // If pg exists, draw it. This means all generation has finished and the map is the same from now on
        image(pg, 0, 0);
    }
    
    // If animating, draw potenial building spots in green
    if (buildingGenerator.buildingPoints != null) {
        stroke(#00FF00);
        fill(#00FF00);
        for (Object o : buildingGenerator.buildingPoints) {
            RoadPos rp = (RoadPos) o;
            Point perp = Point.mult(new Point(rp.gradient.y, -rp.gradient.x), 2000);    // Calculate perpendicular vector
            line(rp.x - perp.x, rp.y - perp.y, rp.x + perp.x, rp.y + perp.y);
        }
    }
    
    // If animating, draw potenial road starts in red
    if (roadGenerator.starts != null) {
        stroke(#FF0000);
        fill(#FF0000);
        for (Object o : roadGenerator.starts) {
            StreamPossStart sps = (StreamPossStart) o;
            circle(sps.sp.x, sps.sp.y, 2);
        }
    }
    
    // Calls interact methods for UI
    for (UIElement uie : ui.values()) {
        if (uie.draw) uie.draw(ms, this.g);
    }
    
}

void keyPressed() {
    if (key == 's') {       // Saves img
        saveMap();
    }
    
    if (key == 'g') {       // Generate new map
        fastMode = false;
        generateInit();
    }
    
    if (key == 'f') {       // Fast generate new map
        fastMode = true;
        generateInit();
    }
    
    if (key == 'n' && manualMode) {
        genStep();
    }
    
    if (key == 'h') {
        UIElement uie = ui.get("buttonCollection");
        uie.draw = !uie.draw;
    }
}

void saveMap() {
    PGraphics saveGraphics = createGraphics(width, height);
    PGraphics drawG = pg != null ? pg : g;
    saveGraphics.beginDraw();
    saveGraphics.image(drawG, 0, 0);
    ui.get("nameText").draw(20, saveGraphics);
    saveGraphics.endDraw();
    String name = String.format("output %02d-%02d-%02d %02d-%02d-%02d %s.png", year(), month(), day(), hour(), minute(), second(), settings.seed);
    saveGraphics.save(name);
    println("Saved map as", name);
}
